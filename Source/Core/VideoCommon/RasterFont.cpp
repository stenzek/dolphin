// Copyright 2018 Dolphin Emulator Project
// Licensed under GPLv2+
// Refer to the license.txt file included.

#include "VideoCommon/RasterFont.h"
#include "Common/Assert.h"
#include "VideoCommon/AbstractPipeline.h"
#include "VideoCommon/AbstractShader.h"
#include "VideoCommon/AbstractTexture.h"
#include "VideoCommon/NativeVertexFormat.h"
#include "VideoCommon/RenderBase.h"
#include "VideoCommon/RenderState.h"
#include "VideoCommon/VertexManagerBase.h"
#include "VideoCommon/VertexShaderGen.h"

#include <array>
#include <sstream>
#include <vector>

namespace VideoCommon
{
constexpr u32 CHARACTER_WIDTH = 8;
constexpr u32 CHARACTER_HEIGHT = 13;
constexpr u32 CHARACTER_OFFSET = 32;
constexpr u32 CHARACTER_COUNT = 95;

constexpr u32 TEXTURE_WIDTH = CHARACTER_WIDTH * CHARACTER_COUNT;
constexpr u32 TEXTURE_HEIGHT = CHARACTER_HEIGHT;

static constexpr std::array<u8, CHARACTER_COUNT* CHARACTER_HEIGHT> s_raster_font_texture = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
     0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff,
     0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e,
     0x18, 0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70, 0x00, 0x00,
     0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30,
     0x30, 0x30, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
     0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18,
     0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
     0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03,
     0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c, 0x00, 0x00, 0x7e,
     0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18, 0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60,
     0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e, 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07,
     0x03, 0x03, 0xe7, 0x7e, 0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c,
     0x0c, 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00,
     0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e, 0x00, 0x00, 0x30, 0x30, 0x30,
     0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff, 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e,
     0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3,
     0xe7, 0x7e, 0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0c,
     0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
     0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c,
     0x18, 0x30, 0x60, 0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e,
     0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3,
     0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3,
     0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
     0xc0, 0xc0, 0xe7, 0x7e, 0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce,
     0xfc, 0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00,
     0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff, 0x00, 0x00, 0x7e, 0xe7, 0xc3,
     0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff,
     0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
     0x18, 0x7e, 0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x00,
     0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3, 0x00, 0x00, 0xff, 0xc0,
     0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
     0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3, 0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3,
     0xf3, 0xe3, 0xe3, 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e,
     0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0x00, 0x00, 0x3f,
     0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8,
     0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0,
     0xc0, 0xc0, 0xe7, 0x7e, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
     0xff, 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00, 0x00,
     0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0xc3, 0xe7, 0xff,
     0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18,
     0x3c, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66,
     0x66, 0xc3, 0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff, 0x00,
     0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x03, 0x03, 0x06,
     0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60, 0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c,
     0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3,
     0x66, 0x3c, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70, 0x00, 0x00, 0x7f,
     0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3,
     0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03,
     0x03, 0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e, 0x7e, 0xc3, 0x03, 0x03, 0x7f,
     0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
     0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00,
     0x18, 0x00, 0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00, 0x00,
     0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x7e, 0x18,
     0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb,
     0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
     0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03,
     0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0,
     0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30,
     0x00, 0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xe7, 0xff,
     0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66,
     0xc3, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f, 0x18, 0x18, 0x18, 0x18,
     0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c,
     0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60,
     0x00, 0x00, 0x00}};

RasterFont::RasterFont() = default;
RasterFont::~RasterFont() = default;

bool RasterFont::Initialize(AbstractTextureFormat framebuffer_format)
{
  m_framebuffer_format = framebuffer_format;
  CreateVertexFormat();
  return CompileShaders() && CreatePipeline() && CreateTexture();
}

bool RasterFont::SetFramebufferFormat(AbstractTextureFormat format)
{
  if (m_framebuffer_format == format)
    return true;

  m_pipeline.reset();
  m_framebuffer_format = format;
  return CreatePipeline();
}

void RasterFont::RenderText(const std::string& str, float x, float y, u32 color, u32 viewport_width,
                            u32 viewport_height, bool shadow)
{
  // Generate vertices.
  if (shadow)
    GenerateVertices(str, x, y, color, viewport_width, viewport_height, true);
  GenerateVertices(str, x, y, color, viewport_width, viewport_height, false);
  if (m_vertices.empty())
    return;

  // Upload and draw.
  g_renderer->SetTexture(0, m_texture.get());
  g_renderer->SetSamplerState(0, RenderState::GetLinearSamplerState());
  g_renderer->SetPipeline(m_pipeline.get());
  g_renderer->DrawUtilityPipeline(nullptr, 0, m_vertices.data(), sizeof(Vertex),
                                  static_cast<u32>(m_vertices.size()));

  // Clean up for next draw.
  m_vertices.clear();
}

bool RasterFont::CreateTexture()
{
  std::vector<u8> data(TEXTURE_WIDTH * TEXTURE_HEIGHT * 4);
  for (int y = 0; y < CHARACTER_HEIGHT; y++)
  {
    for (int c = 0; c < CHARACTER_COUNT; c++)
    {
      for (int x = 0; x < CHARACTER_WIDTH; x++)
      {
        bool pixel = (0 != (s_raster_font_texture[c * CHARACTER_HEIGHT + y] &
                            (1 << (CHARACTER_WIDTH - x - 1))));
        u8 value = pixel ? 0xFF : 0x00;
        size_t index = (CHARACTER_WIDTH * CHARACTER_COUNT * y + CHARACTER_WIDTH * c + x) * 4;
        data[index++] = value;
        data[index++] = value;
        data[index++] = value;
        data[index++] = value;
      }
    }
  }

  TextureConfig config(TEXTURE_WIDTH, TEXTURE_HEIGHT, 1, 1, 1, AbstractTextureFormat::RGBA8, false);
  m_texture = g_renderer->CreateTexture(config);
  if (!m_texture)
    return false;

  m_texture->Load(0, TEXTURE_WIDTH, TEXTURE_HEIGHT, TEXTURE_WIDTH, data.data(), data.size());
  return true;
}

bool RasterFont::CompileShaders()
{
  const APIType api_type = g_ActiveConfig.backend_info.api_type;

  // Vertex Shader
  {
    std::stringstream ss;
    if (api_type == APIType::D3D)
    {
      ss << "void main(in float2 rawpos : POSITION,\n"
         << "          in float2 rawtex0 : TEXCOORD,\n"
         << "          in float4 rawcolor0 : COLOR,\n"
         << "          out float2 frag_uv : TEXCOORD,\n"
         << "          out float4 frag_color : COLOR,\n"
         << "          out float4 out_pos : SV_Position)\n";
    }
    else
    {
      ss << "ATTRIBUTE_LOCATION(" << SHADER_POSITION_ATTRIB << ") in float2 rawpos;\n"
         << "ATTRIBUTE_LOCATION(" << SHADER_TEXTURE0_ATTRIB << ") in float2 rawtex0;\n"
         << "ATTRIBUTE_LOCATION(" << SHADER_COLOR0_ATTRIB << ") in float4 rawcolor0;\n"
         << "VARYING_LOCATION(0) out float2 frag_uv;\n"
         << "VARYING_LOCATION(1) out float4 frag_color;\n"
         << "void main()\n";
    }

    ss << "{\n"
       << "  frag_uv = rawtex0;\n"
       << "  frag_color = rawcolor0;\n";

    if (api_type == APIType::D3D)
    {
      ss << "  out_pos = float4(rawpos, 0.0, 1.0);\n";
    }
    else
    {
      ss << "  gl_Position = float4(rawpos, 0.0, 1.0);\n";
      if (api_type == APIType::Vulkan)
        ss << "  gl_Position.y = -gl_Position.y;\n";
    }

    ss << "}\n";

    std::string source = ss.str();
    m_vertex_shader =
        g_renderer->CreateShaderFromSource(ShaderStage::Vertex, source.c_str(), source.length());
  }

  // Pixel Shader
  {
    std::stringstream ss;
    if (api_type == APIType::D3D)
    {
      ss << "Texture2DArray tex0 : register(t0);\n"
         << "SamplerState samp0 : register(s0);\n"
         << "void main(in float2 frag_uv : TEXCOORD,\n"
         << "          in float4 frag_color : COLOR,\n"
         << "          out float4 ocol0 : SV_Target)\n";
    }
    else
    {
      ss << "SAMPLER_BINDING(0) uniform sampler2DArray samp0;\n"
         << "VARYING_LOCATION(0) in float2 frag_uv; \n"
         << "VARYING_LOCATION(1) in float4 frag_color;\n"
         << "FRAGMENT_OUTPUT_LOCATION(0) out float4 ocol0;\n"
         << "void main()\n";
    }

    ss << "{\n";

    if (api_type == APIType::D3D)
      ss << "  ocol0 = tex0.Sample(samp0, float3(frag_uv, 0.0)) * frag_color;\n";
    else
      ss << "  ocol0 = texture(samp0, float3(frag_uv, 0.0)) * frag_color;\n";

    ss << "}\n";

    std::string source = ss.str();
    m_pixel_shader =
        g_renderer->CreateShaderFromSource(ShaderStage::Pixel, source.c_str(), source.length());
  }

  return m_vertex_shader && m_pixel_shader;
}

bool RasterFont::CreatePipeline()
{
  AbstractPipelineConfig pconfig = {};
  pconfig.vertex_format = m_vertex_format.get();
  pconfig.vertex_shader = m_vertex_shader.get();
  pconfig.pixel_shader = m_pixel_shader.get();
  pconfig.rasterization_state.hex = RenderState::GetNoCullRasterizationState().hex;
  pconfig.rasterization_state.primitive = PrimitiveType::Triangles;
  pconfig.depth_state.hex = RenderState::GetNoDepthTestingDepthStencilState().hex;
  pconfig.blending_state.hex = RenderState::GetNoBlendingBlendState().hex;
  pconfig.blending_state.blendenable = true;
  pconfig.blending_state.srcfactor = BlendMode::SRCALPHA;
  pconfig.blending_state.dstfactor = BlendMode::INVSRCALPHA;
  pconfig.blending_state.srcfactoralpha = BlendMode::ZERO;
  pconfig.blending_state.dstfactoralpha = BlendMode::ONE;
  pconfig.framebuffer_state.color_texture_format = m_framebuffer_format;
  pconfig.framebuffer_state.depth_texture_format = AbstractTextureFormat::Undefined;
  pconfig.framebuffer_state.samples = 1;
  pconfig.framebuffer_state.per_sample_shading = false;
  pconfig.usage = AbstractPipelineUsage::Utility;
  m_pipeline = g_renderer->CreatePipeline(pconfig);
  return m_pipeline != nullptr;
}

bool RasterFont::IsPrintableCharacter(char ch)
{
  return ch >= static_cast<char>(CHARACTER_OFFSET) &&
         ch <= static_cast<char>(CHARACTER_OFFSET + CHARACTER_COUNT) && ch != ' ';
}

void RasterFont::CreateVertexFormat()
{
  PortableVertexDeclaration vdecl = {};
  vdecl.position = {VAR_FLOAT, 2, offsetof(RasterFont::Vertex, x), true, false};
  vdecl.texcoords[0] = {VAR_FLOAT, 2, offsetof(RasterFont::Vertex, u), true, false};
  vdecl.colors[0] = {VAR_UNSIGNED_BYTE, 4, offsetof(RasterFont::Vertex, color), true, false};
  vdecl.stride = sizeof(RasterFont::Vertex);
  m_vertex_format = g_vertex_manager->CreateNativeVertexFormat(vdecl);
  _assert_(m_vertex_format != nullptr);
}

void RasterFont::GenerateCharacterVertices(char ch, float current_x, float current_y, u32 color,
                                           float delta_x, float delta_y)
{
  constexpr float inv_character_count = 1.0f / static_cast<float>(CHARACTER_COUNT);

  Vertex vertex;
  vertex.x = current_x;
  vertex.y = current_y;
  vertex.u = static_cast<float>(ch - CHARACTER_OFFSET) * inv_character_count;
  vertex.v = 0.0f;
  vertex.color = color;
  m_vertices.push_back(vertex);

  vertex.x = current_x + delta_x;
  vertex.y = current_y;
  vertex.u = static_cast<float>(ch - CHARACTER_OFFSET + 1) * inv_character_count;
  vertex.v = 0.0f;
  vertex.color = color;
  m_vertices.push_back(vertex);

  vertex.x = current_x + delta_x;
  vertex.y = current_y + delta_y;
  vertex.u = static_cast<float>(ch - CHARACTER_OFFSET + 1) * inv_character_count;
  vertex.v = 1.0f;
  vertex.color = color;
  m_vertices.push_back(vertex);

  vertex.x = current_x;
  vertex.y = current_y;
  vertex.u = static_cast<float>(ch - CHARACTER_OFFSET) * inv_character_count;
  vertex.v = 0.0f;
  vertex.color = color;
  m_vertices.push_back(vertex);

  vertex.x = current_x + delta_x;
  vertex.y = current_y + delta_y;
  vertex.u = static_cast<float>(ch - CHARACTER_OFFSET + 1) * inv_character_count;
  vertex.v = 1.0f;
  vertex.color = color;
  m_vertices.push_back(vertex);

  vertex.x = current_x;
  vertex.y = current_y + delta_y;
  vertex.u = static_cast<float>(ch - CHARACTER_OFFSET) * inv_character_count;
  vertex.v = 1.0f;
  vertex.color = color;
  m_vertices.push_back(vertex);
}

void RasterFont::GenerateVertices(const std::string& str, float x, float y, u32 color,
                                  u32 viewport_width, u32 viewport_height, bool shadow)
{
  const float delta_x = static_cast<float>(CHARACTER_WIDTH * 2) / viewport_width;
  const float delta_y = static_cast<float>(CHARACTER_HEIGHT * 2) / viewport_height;
  const float border_x = 2.0f / viewport_width;
  const float border_y = 4.0f / viewport_height;
  const float shadow_offset_x = shadow ? (2.0f / viewport_width) : 0.0f;
  const float shadow_offset_y = shadow ? (-2.0f / viewport_height) : 0.0f;
  const u32 shadow_color = shadow ? (color & 0xFF000000) : color;

  const float start_x = x * 2.0f / viewport_width - 1.0f;
  float current_x = start_x;
  float current_y = 1.0f - y * 2.0f / viewport_height;

  for (char ch : str)
  {
    if (ch == '\n')
    {
      current_x = start_x;
      current_y -= delta_y + border_y;
      continue;
    }

    // do not print spaces, they can be skipped easily
    if (ch == ' ')
    {
      current_x += delta_x + border_x;
      continue;
    }

    if (!IsPrintableCharacter(ch))
      continue;

    GenerateCharacterVertices(ch, current_x + shadow_offset_x, current_y + shadow_offset_y,
                              shadow_color, delta_x, delta_y);
    current_x += delta_x + border_x;
  }
}

}  // namespace RasterFont
